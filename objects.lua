local Class = require "class"
local Vector = require "vector"

local Object = Class:derive("Object")

--[[DOCUMENTATION:
	
	Drawing types:
		Polygon - draw a filled solid color
		Image - takes a similarly shaped image to the collision shape
		Texture - takes any image and matches it to the collision shape using repeating

]]

local drawHitboxes = true

function Object:new(args)
	self.drawing = args.drawing
	self.body = love.physics.newBody(world,args.position[1],args.position[2],args.bodyType)
	if args.shape.type == "rectangle" then
		self.shape = love.physics.newRectangleShape(args.shape.size[1],args.shape.size[2])
		self.size = args.shape.size --width and height
		self.position = args.position:take(Vector(self.size[1]/2,self.size[2]/2))--top left hand corner
	end
	if args.shape.type == "circle" then
		self.shape = love.physics.newCircleShape(args.shape.radius)
	end
	self.fixture = love.physics.newFixture(self.body,self.shape,args.density)
	if args.drawing.type == "texture" then
		self:generateImageCanvas()
	end
	self.toRemove = false
end

function Object:generateImageCanvas()
	--Generate mesh from shape
	local verticesA = {self.shape:getPoints()}
	local verticesB = {}
	local meshSize = Vector(0,0)
	for i=1,#verticesA/2 do
		local x,y = verticesA[i*2-1]*2,verticesA[i*2]*2
		verticesB[i]={x,y,x/self.drawing.texture:getWidth(),y/self.drawing.texture:getHeight(),1,1,1}
		if x>meshSize[1] then meshSize[1] = x end
		if y>meshSize[2] then meshSize[2] = y end
	end
	local mesh = love.graphics.newMesh(verticesB,"fan","dynamic")
	--Applying texture
	self.drawing.texture:setWrap("repeat","repeat","repeat")
	mesh:setTexture(self.drawing.texture)
	--Creating blank canvas
	local canvas = love.graphics.newCanvas(meshSize[1],meshSize[2])
    love.graphics.setCanvas(canvas)
    love.graphics.clear()
    love.graphics.setBlendMode("alpha")
    love.graphics.setColor(1,1,1)
    --Rendering the mesh to the canvas
    love.graphics.draw(mesh)
    love.graphics.setCanvas()
    self.drawing.image = canvas
end

function Object:draw()
	if self.drawing.type == "image" or self.drawing.type == "texture"then
		love.graphics.setColor(1,1,1)
		love.graphics.draw(self.drawing.image,self.body:getX(),self.body:getY(),self.body:getAngle(),1,1,self.drawing.image:getWidth()/2,self.drawing.image:getHeight()/2)
	elseif self.drawing.type == "polygon" then
		love.graphics.setColor(0.20, 0.20, 0.20)
		love.graphics.polygon("fill", self.body:getWorldPoints(self.shape:getPoints()))
	end
end

function Object:drawHitbox()
	love.graphics.setColor(1,1,1)
	love.graphics.polygon("line", self.body:getWorldPoints(self.shape:getPoints()))
end

function Object:remove()
	self.toRemove = true
end

----------------------

local objects = {}

function objects.load()
    love.physics.setMeter(64) --the length of a meter our worlds will be 64px
    world = love.physics.newWorld(0, 9.81*64, true) --create a world for the bodies to exist in with horizontal gravity of 0 and vertical gravity of 9.81
end

function objects.add(args)
	objects[#objects+1] = Object(args)
end

function objects.update(dt)
    if inGame == true and inGameMenu == false then
        world:update(dt)
    
        --here we are going to create some keyboard events
        if love.keyboard.isDown("d") then --press the d key to push the ball to the right
            objects.ball.body:applyForce(400, 0)
        elseif love.keyboard.isDown("a") then --press the a key to push the ball to the left
            objects.ball.body:applyForce(-400, 0)
        elseif love.keyboard.isDown("space") then --press the space key to set the ball in the air
            objects.ball.body:setPosition(650/2, 650/2)
            objects.ball.body:setLinearVelocity(0, 0) --we must set the velocity to zero to prevent a potentially large velocity generated by the change in position
        end
    end

    objects.cleanup()

end

function objects.draw()
	if inGame == true then
		for i=1,#objects do
			objects[i]:draw()
		end
		if drawHitboxes then
			for i=1,#objects do
				objects[i]:drawHitbox()
			end
		end
	end
end

function objects.cleanup()
	for i=#objects,1,-1 do
		if objects[i].toRemove then
			table.remove(objects,i)
		end
	end
end

return objects